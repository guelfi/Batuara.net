name: Deploy to Oracle Cloud Infrastructure

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_API: ${{ github.repository }}-api
  IMAGE_NAME_FRONTEND: ${{ github.repository }}-frontend

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: |
          src/Frontend/package-lock.json
          src/Frontend/PublicWebsite/package-lock.json
          src/Frontend/AdminDashboard/package-lock.json
        
    - name: Restore .NET dependencies
      run: dotnet restore
      
    - name: Build .NET solution
      run: dotnet build --no-restore --configuration Release /p:Platform="Any CPU"
      
    - name: Install Frontend root dependencies
      run: |
        cd src/Frontend
        npm ci
        
    - name: Install PublicWebsite dependencies
      run: |
        cd src/Frontend/PublicWebsite
        npm ci
        
    - name: Install AdminDashboard dependencies
      run: |
        cd src/Frontend/AdminDashboard
        npm ci
        
    - name: Build PublicWebsite
      run: |
        cd src/Frontend/PublicWebsite
        npm run build
        
    - name: Build AdminDashboard
      run: |
        cd src/Frontend/AdminDashboard
        npm run build

  build-images:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    permissions:
      contents: read
      packages: write
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata for API
      id: meta-api
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_API }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Extract metadata for Frontend
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and push API image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.api
        push: true
        tags: ${{ steps.meta-api.outputs.tags }}
        labels: ${{ steps.meta-api.outputs.labels }}
        platforms: linux/amd64
        
    - name: Build and push Frontend image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.frontend
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}
        platforms: linux/amd64

  deploy-to-oci:
    needs: build-images
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    environment:
      name: production
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.OCI_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H 129.153.86.168 >> ~/.ssh/known_hosts
      
    - name: Deploy to Oracle Cloud
      run: |
        ssh -o StrictHostKeyChecking=no ubuntu@129.153.86.168 << 'EOF'
          set -ex
          sudo apt-get update
          sudo apt-get install -y lsof
          
          # Definir vari√°veis com isolamento
          PROJECT_NAME="batuara"
          PROJECT_DIR="/var/www/batuara_net"
          BACKUP_DIR="/var/www/backups/${PROJECT_NAME}_backup_$(date +%Y%m%d_%H%M%S)"
          COMPOSE_PROJECT_NAME="batuara-net"
          
          # Portas espec√≠ficas do Batuara (isoladas dos outros projetos)
          PUBLIC_WEBSITE_PORT=3000
          ADMIN_DASHBOARD_PORT=3001
          API_PORT=8080
          
          # Verificar conflitos de porta antes do deploy
          echo "üîç Verificando conflitos de porta..."
          check_port_conflict() {
            local port=$1
            local service=$2
            if ss -tuln | grep -q ":$port "; then
              local pid=$(lsof -ti:$port 2>/dev/null || echo "unknown")
              echo "‚ö†Ô∏è  Porta $port ($service) est√° em uso (PID: $pid)"
              # Verificar se √© do nosso projeto
              local container_name=$(docker ps --format "{{.Names}}" --filter "publish=$port")
              if [[ -n "$container_name" && "$container_name" == *"$COMPOSE_PROJECT_NAME"* ]]; then
                echo "‚úÖ Porta $port pertence ao projeto $PROJECT_NAME - continuando..."
              else
                echo "‚ùå Conflito de porta detectado! Porta $port est√° sendo usada por outro servi√ßo."
                return 1
              fi
            else
              echo "‚úÖ Porta $port ($service) dispon√≠vel"
            fi
          }
          
          check_port_conflict $PUBLIC_WEBSITE_PORT "Website P√∫blico"
          check_port_conflict $ADMIN_DASHBOARD_PORT "Dashboard Admin"
          check_port_conflict $API_PORT "API Backend"
          
          echo "üöÄ Iniciando deploy do Batuara.net..."
          
          # Criar diret√≥rios se n√£o existirem
          sudo mkdir -p /var/www/backups
          sudo mkdir -p $PROJECT_DIR
          
          # Fazer backup se projeto existir
          if [ -d "$PROJECT_DIR/.git" ]; then
            echo "üì¶ Criando backup..."
            sudo cp -r $PROJECT_DIR $BACKUP_DIR
            echo "‚úÖ Backup criado em: $BACKUP_DIR"
          fi
          
          # Navegar para diret√≥rio do projeto
          cd $PROJECT_DIR
          
          # Parar apenas containers do nosso projeto
          echo "‚èπÔ∏è Parando containers do projeto $PROJECT_NAME..."
          if [ -f "docker-compose.prod.yml" ]; then
            timeout 60 docker-compose -f docker-compose.prod.yml -p $COMPOSE_PROJECT_NAME down --remove-orphans 2>/dev/null || true
          fi
          
          # Limpar apenas containers √≥rf√£os do nosso projeto
          docker container ls -a --filter "label=com.docker.compose.project=$COMPOSE_PROJECT_NAME" -q | xargs -r docker rm -f 2>/dev/null || true
          
          # Atualizar c√≥digo
          echo "üì• Atualizando c√≥digo..."
          if [ -d ".git" ]; then
            git fetch origin
            git reset --hard origin/${{ github.ref_name }}
          else
            git clone -b ${{ github.ref_name }} https://github.com/${{ github.repository }}.git .
          fi
          
          # Login no registry
          echo "üîê Fazendo login no registry..."
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          
          # Usar docker-compose de produ√ß√£o existente
          echo "üê≥ Configurando ambiente de produ√ß√£o..."
          cp docker-compose.production.yml docker-compose.prod.yml
          
          # Configurar vari√°veis de ambiente com isolamento
          cat > .env.production << 'ENVEOF'
          COMPOSE_PROJECT_NAME=batuara-net
          ENVIRONMENT=production
          PROJECT_NAME=batuara
          
          # URLs da API (isoladas)
          REACT_APP_API_URL=http://${{ secrets.OCI_SERVER_IP }}:3003
          VITE_API_BASE_URL_TEST=http://${{ secrets.OCI_SERVER_IP }}:3003
          
          # Portas dos servi√ßos (espec√≠ficas do Batuara)
          PUBLIC_WEBSITE_PORT=3000
          ADMIN_DASHBOARD_PORT=3001
          API_PORT=3003
          
          # Rede Docker isolada
          DOCKER_NETWORK=batuara-network
          
          # Database com prefixo
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=batuara_db
          
          # Volumes com prefixo para isolamento
          VOLUME_PREFIX=batuara
          ENVEOF
          
          # Criar rede Docker isolada se n√£o existir
          echo "üåê Configurando rede Docker isolada..."
          docker network create batuara-network 2>/dev/null || echo "Rede batuara-network j√° existe"
          
          # Iniciar os servi√ßos com isolamento
          echo "üöÄ Iniciando servi√ßos do $PROJECT_NAME..."
          docker-compose -f docker-compose.prod.yml --env-file .env.production -p $COMPOSE_PROJECT_NAME pull
          docker-compose -f docker-compose.prod.yml --env-file .env.production -p $COMPOSE_PROJECT_NAME up -d --build
          
          # Verificar se outros projetos ainda est√£o rodando
          echo "üìä Verificando status de outros projetos..."
          if docker ps --format "table {{.Names}}\t{{.Status}}" | grep -E "mobilemed|other-project" > /dev/null 2>&1; then
            echo "‚úÖ Outros projetos continuam executando normalmente"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "mobilemed|batuara"
          else
            echo "‚ÑπÔ∏è  Nenhum outro projeto detectado em execu√ß√£o"
          fi
          
          # Aguardar inicializa√ß√£o com timeout
          echo "‚è≥ Aguardando inicializa√ß√£o dos servi√ßos..."
          sleep 45
          
          # Health checks robustos
          echo "üîç Executando health checks..."
          
          # Fun√ß√£o para health check com retry
          health_check() {
            local url=$1
            local service=$2
            local max_attempts=10
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              if curl -f --connect-timeout 5 --max-time 10 $url > /dev/null 2>&1; then
                echo "‚úÖ $service: OK"
                return 0
              fi
              echo "‚è≥ $service: Tentativa $attempt/$max_attempts..."
              sleep 6
              attempt=$((attempt + 1))
            done
            
            echo "‚ùå $service: FALHA ap√≥s $max_attempts tentativas"
            return 1
          }
          
          # Executar health checks
          HEALTH_FAILED=0
          health_check "http://localhost:3000" "Website P√∫blico" || HEALTH_FAILED=1
          health_check "http://localhost:3001" "Dashboard Admin" || HEALTH_FAILED=1
          health_check "http://localhost:3003/health" "API Backend" || HEALTH_FAILED=1
          
          # Verificar status dos containers do nosso projeto
          echo "üìä Status dos containers do $PROJECT_NAME:"
          docker-compose -f docker-compose.prod.yml -p $COMPOSE_PROJECT_NAME ps
          
          # Mostrar resumo de todos os projetos ativos
          echo "\nüåê Resumo de todos os projetos na OCI:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | head -1
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "batuara|mobilemed" || echo "Nenhum projeto encontrado"
          
          # Rollback em caso de falha
          if [ $HEALTH_FAILED -eq 1 ]; then
            echo "‚ùå Health checks falharam. Iniciando rollback..."
            
            # Parar apenas containers do nosso projeto com falha
            docker-compose -f docker-compose.prod.yml -p $COMPOSE_PROJECT_NAME down
            
            # Restaurar backup se existir
            if [ -d "$BACKUP_DIR" ]; then
              echo "üîÑ Restaurando backup..."
              rm -rf $PROJECT_DIR/*
              cp -r $BACKUP_DIR/* $PROJECT_DIR/
              cd $PROJECT_DIR
              docker-compose up -d
              echo "‚úÖ Rollback conclu√≠do"
            fi
            
            exit 1
          fi
          
          echo "üéâ Deploy conclu√≠do com sucesso!"
          echo "üåê Website: http://${{ secrets.OCI_SERVER_IP }}:3000"
          echo "üîß Dashboard: http://${{ secrets.OCI_SERVER_IP }}:3001"
          echo "üöÄ API: http://${{ secrets.OCI_SERVER_IP }}:3003"
        EOF

  notify-deployment:
    needs: deploy-to-oci
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Notify deployment status
      run: |
        if [ "${{ needs.deploy-to-oci.result }}" == "success" ]; then
          echo "‚úÖ Deploy realizado com sucesso!"
          echo "üåê Website: http://${{ secrets.OCI_SERVER_IP }}:3000"
          echo "üîß Dashboard: http://${{ secrets.OCI_SERVER_IP }}:3001"
          echo "üöÄ API: http://${{ secrets.OCI_SERVER_IP }}:3003"
        else
          echo "‚ùå Deploy falhou. Verifique os logs para mais detalhes."
          exit 1
        fi