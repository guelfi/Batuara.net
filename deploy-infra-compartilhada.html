<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guia de Implantação | Infraestrutura Compartilhada</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <style>
        body { background-color: #f8f9fa; }
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            width: 280px;
            padding: 20px;
            background-color: #343a40;
            color: white;
            overflow-y: auto;
        }
        .sidebar .nav-link { color: #adb5bd; }
        .sidebar .nav-link.active { color: #ffffff; font-weight: bold; }
        .sidebar .nav-link:hover { color: #ffffff; }
        .main-content { margin-left: 300px; padding: 20px; }
        .code-block { position: relative; margin-bottom: 1rem; }
        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s;
        }
        .code-block:hover .copy-btn { opacity: 1; }
        .copy-btn:hover { background-color: #5a6268; }
        h2, h3, h4 { padding-top: 20px; border-bottom: 1px solid #dee2e6; padding-bottom: 10px; margin-top: 20px;}
        .callout {
            padding: 1.25rem;
            margin-top: 1.25rem;
            margin-bottom: 1.25rem;
            border: 1px solid #e9ecef;
            border-left-width: .25rem;
            border-radius: .25rem;
        }
        .callout-info { border-left-color: #0dcaf0; }
        .callout-warning { border-left-color: #ffc107; }
        .callout-danger { border-left-color: #dc3545; }
        .callout-success { border-left-color: #198754; }
        .nav-pills .nav-link { margin-bottom: 5px; }
    </style>
</head>
<body>

    <div class="sidebar">
        <h4 class="mb-4">Infraestrutura Compartilhada</h4>
        <nav class="nav flex-column nav-pills">
            <a class="nav-link" href="#introducao">1. Introdução</a>
            <a class="nav-link" href="#preparacao-servidor">2. Preparação do Servidor</a>
            <a class="nav-link" href="#estrutura-arquivos">3. Estrutura de Arquivos</a>
            <a class="nav-link" href="#dockerfiles-comuns">4. Dockerfiles Comuns</a>
            <a class="nav-link" href="#nginx-proxy">5. Nginx Proxy & SSL</a>
            <a class="nav-link" href="#backups">6. Backups Automatizados</a>
            <a class="nav-link" href="#configuracao-dns-registrobr">7. Configuração DNS (Registro.br)</a>
            <a class="nav-link" href="#manutencao">8. Manutenção</a>
            <a class="nav-link" href="#validacao-final">9. Validação Final</a>
        </nav>
    </div>

    <div class="main-content">
        <div class="text-center">
            <h1 class="display-5">Guia de Implantação</h1>
            <h1 class="display-5">Infraestrutura Compartilhada</h1>
        </div>
        <p class="lead mt-3">Este guia abrange a configuração da infraestrutura base para os projetos DriverHub e Batuara.net na Oracle Cloud.</p>

        <section id="introducao">
            <h2>1. Introdução</h2>
            <p>Este documento detalha a configuração da infraestrutura compartilhada necessária para hospedar as aplicações DriverHub e Batuara.net em um servidor Ubuntu na Oracle Cloud. Ele inclui a preparação do servidor, a configuração do Docker, do Nginx como proxy reverso (com SSL) e a automação de backups.</p>
            <p>Após configurar esta infraestrutura, você poderá seguir os guias específicos para cada projeto (DriverHub e Batuara.net) para implantar suas respectivas aplicações.</p>
        </section>

        <section id="preparacao-servidor">
            <h2>2. Preparação do Servidor</h2>
            <p>Esta seção detalha os passos iniciais para configurar seu servidor Ubuntu na Oracle Cloud. Todos os comandos devem ser executados no terminal do seu servidor, após conectar-se via SSH.</p>

            <h4>2.1. Conexão SSH</h4>
            <div class="callout callout-info">
                <strong>Onde executar:</strong> No terminal do seu computador local.
                <br><strong>Propósito:</strong> Conectar-se ao seu servidor remoto.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">ssh -i ~/Oracle/ssh-key-2025-07-15.key ubuntu@$(curl -s ifconfig.me)</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Após executar o comando, você deverá ver o prompt de comando do seu servidor (ex: <code>ubuntu@seu-servidor:~$</code>).
            </div>

            <h4>2.2. Atualizar o Sistema</h4>
            <div class="callout callout-info">
                <strong>Onde executar:</strong> No terminal do servidor (após conectar via SSH).
                <br><strong>Propósito:</strong> Garantir que todos os pacotes do sistema operacional estejam atualizados.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">sudo apt update && sudo apt upgrade -y</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> O comando deve ser concluído sem erros significativos. Você verá uma lista de pacotes sendo atualizados.
            </div>

            <h4>2.3. Instalar Docker e Docker Compose</h4>
            <div class="callout callout-info">
                <strong>Onde executar:</strong> No terminal do servidor.
                <br><strong>Propósito:</strong> Instalar as ferramentas Docker e Docker Compose, essenciais para rodar suas aplicações em contêineres.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">sudo apt install -y docker.io docker-compose</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> O comando deve ser concluído sem erros. Para verificar a instalação, execute: <code>docker --version</code> e <code>docker-compose --version</code>. Ambos devem retornar as versões instaladas.
            </div>

            <h4>2.4. Instalar Nginx</h4>
            <div class="callout callout-info">
                <strong>Onde executar:</strong> No terminal do servidor.
                <br><strong>Propósito:</strong> Instalar o Nginx, que atuará como proxy reverso para suas aplicações.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">sudo apt install -y nginx</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Para verificar a instalação, execute: <code>nginx -v</code>. O comando deve retornar a versão do Nginx.
            </div>

            <h4>2.5. Gerenciar o Serviço Docker</h4>
            <div class="callout callout-info">
                <strong>Onde executar:</strong> No terminal do servidor.
                <br><strong>Propósito:</strong> Iniciar o serviço Docker e configurá-lo para iniciar automaticamente com o sistema.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">sudo systemctl start docker
sudo systemctl enable docker</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Para verificar o status do serviço, execute: <code>sudo systemctl status docker</code>. Ele deve mostrar <code>active (running)</code>.
            </div>

            <h4>2.6. Adicionar Usuário 'ubuntu' ao Grupo Docker</h4>
            <div class="callout callout-info">
                <strong>Onde executar:</strong> No terminal do servidor.
                <br><strong>Propósito:</strong> Permitir que o usuário <code>ubuntu</code> execute comandos Docker sem precisar digitar <code>sudo</code> a cada vez.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">sudo usermod -aG docker ubuntu</code></pre>
            </div>
            <div class="callout callout-warning">
                <strong>Importante:</strong> Você precisa <strong>sair da sessão SSH e conectar-se novamente</strong> para que essa alteração tenha efeito. Isso é crucial para que as permissões sejam aplicadas.
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Após reconectar, tente executar <code>docker ps</code>. Se não pedir senha e mostrar a lista de contêineres (mesmo que vazia), as permissões foram aplicadas corretamente.
            </div>

            <h4>2.7. Configurar o Firewall (UFW)</h4>
            <div class="callout callout-info">
                <strong>Onde executar:</strong> No terminal do servidor.
                <br><strong>Propósito:</strong> Configurar o firewall para permitir o tráfego necessário para o SSH (sua conexão) e para o Nginx (serviço web).
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">sudo ufw allow 'OpenSSH'
sudo ufw allow 'Nginx Full'
sudo ufw enable</code></pre>
            </div>
            <div class="callout callout-warning">
                <strong>Atenção:</strong> Ao executar <code>sudo ufw enable</code>, você será perguntado se deseja continuar. Digite <code>y</code> e pressione Enter.
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Para verificar o status do firewall, execute: <code>sudo ufw status</code>. Ele deve mostrar <code>Status: active</code> e as regras para OpenSSH e Nginx Full.
            </div>

            <h4>2.8. Liberar Portas de Teste no Firewall</h4>
            <div class="callout callout-info">
                <strong>Onde executar:</strong> No terminal do servidor.
                <br><strong>Propósito:</strong> Abrir as portas específicas que serão usadas para acessar cada aplicação via IP durante a fase de desenvolvimento e teste.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">sudo ufw allow 8001/tcp
sudo ufw allow 8002/tcp
sudo ufw allow 8003/tcp
sudo ufw allow 8004/tcp</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Execute <code>sudo ufw status numbered</code> para ver as novas regras de firewall listadas.
            </div>
        </section>

        <section id="estrutura-arquivos">
            <h2>3. Estrutura de Arquivos e Redes Docker</h2>
            <p>Esta seção orienta sobre a criação da estrutura de diretórios no servidor e a configuração das redes Docker que serão compartilhadas por todas as suas aplicações.</p>

            <h4>3.1. Criar Diretórios e Atribuir Permissões</h4>
            <div class="callout callout-info">
                <strong>Onde executar:</strong> No terminal do servidor, como usuário <code>ubuntu</code>.
                <br><strong>Propósito:</strong> Organizar os arquivos dos projetos e garantir que o usuário <code>ubuntu</code> tenha permissão total sobre a pasta <code>/var/www</code>.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash"># Criar a estrutura de diretórios base
sudo mkdir -p /var/www/driverhub
sudo mkdir -p /var/www/batuara_net
sudo mkdir -p /var/www/nginx_proxy/config_test
sudo mkdir -p /var/www/nginx_proxy/config_prod
sudo mkdir -p /var/www/dockerfiles

# Atribuir a posse de toda a pasta /var/www ao usuário 'ubuntu'
sudo chown -R ubuntu:ubuntu /var/www
</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Para confirmar que os diretórios foram criados e as permissões estão corretas, execute: <code>ls -l /var/www/</code>. Você deverá ver os diretórios listados e o proprietário como <code>ubuntu</code>.
            </div>

            <h4>3.2. Criar Rede Docker Compartilhada (<code>proxy-net</code>)</h4>
            <div class="callout callout-info">
                <strong>Onde executar:</strong> No terminal do servidor.
                <br><strong>Propósito:</strong> Criar uma rede Docker que permitirá ao contêiner Nginx se comunicar com os contêineres de frontend de ambos os projetos.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">docker network create proxy-net</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Para confirmar que a rede foi criada, execute: <code>docker network ls</code>. Você deverá ver <code>proxy-net</code> na lista.
            </div>
        </section>

        <section id="dockerfiles-comuns">
            <h2>4. Dockerfiles Comuns para Frontends</h2>
            <p>Estes Dockerfiles são modelos genéricos que serão usados para construir as imagens Docker dos seus projetos frontend (React com Vite, Create React App e Expo Web). Eles devem ser criados na pasta <code>/var/www/dockerfiles</code>.</p>

            <h4>4.1. Dockerfile para Frontends Vite (React + Vite)</h4>
            <div class="callout callout-info">
                <strong>Onde criar:</strong> No terminal do servidor, como usuário <code>ubuntu</code>.
                <br><strong>Caminho do arquivo:</strong> <code>/var/www/dockerfiles/Dockerfile.vite</code>
                <br><strong>Propósito:</strong> Define como construir uma aplicação React/Vite em uma imagem Docker.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">cat << 'EOF' > /var/www/dockerfiles/Dockerfile.vite
# Estágio de Build: Usa uma imagem Node.js para instalar dependências e compilar o projeto
FROM node:20-alpine AS build
WORKDIR /app
# Copia os arquivos de configuração de dependências primeiro para aproveitar o cache do Docker
COPY package.json package-lock.json ./
RUN npm install --frozen-lockfile # Instala as dependências
COPY . . # Copia o restante do código-fonte
ARG VITE_API_URL
# Argumento de build para a URL da API
ENV VITE_API_URL=${VITE_API_URL} # Define a variável de ambiente no contêiner
RUN npm run build # Compila o projeto Vite

# Estágio Final: Usa uma imagem Nginx leve para servir os arquivos estáticos
FROM nginx:stable-alpine
COPY --from=build /app/dist /usr/share/nginx/html # Copia os arquivos compilados para o Nginx
COPY /var/www/dockerfiles/nginx.conf /etc/nginx/conf.d/default.conf # Copia a configuração Nginx comum
EXPOSE 80 # Expõe a porta 80 do contêiner
CMD ["nginx", "-g", "daemon off;"] # Inicia o Nginx
EOF
</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Após executar o comando, verifique se o arquivo foi criado corretamente: <code>cat /var/www/dockerfiles/Dockerfile.vite</code>. O conteúdo deve ser o mesmo do bloco acima.
            </div>

            <h4>4.2. Dockerfile para Frontends CRA (Create React App)</h4>
            <div class="callout callout-info">
                <strong>Onde criar:</strong> No terminal do servidor, como usuário <code>ubuntu</code>.
                <br><strong>Caminho do arquivo:</strong> <code>/var/www/dockerfiles/Dockerfile.cra</code>
                <br><strong>Propósito:</strong> Define como construir uma aplicação Create React App em uma imagem Docker.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">cat << 'EOF' > /var/www/dockerfiles/Dockerfile.cra
# Estágio de Build: Usa uma imagem Node.js para instalar dependências e compilar o projeto
FROM node:20-alpine AS build
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm install --frozen-lockfile # Instala as dependências
COPY . . # Copia o restante do código-fonte
ARG REACT_APP_API_URL
# Argumento de build para a URL da API (padrão CRA)
ENV REACT_APP_API_URL=${REACT_APP_API_URL} # Define a variável de ambiente no contêiner
RUN npm run build # Compila o projeto CRA

# Estágio Final: Usa uma imagem Nginx leve para servir os arquivos estáticos
FROM nginx:stable-alpine
COPY --from=build /app/build /usr/share/nginx/html # Copia os arquivos compilados para o Nginx
COPY /var/www/dockerfiles/nginx.conf /etc/nginx/conf.d/default.conf # Copia a configuração Nginx comum
EXPOSE 80 # Expõe a porta 80 do contêiner
CMD ["nginx", "-g", "daemon off;"] # Inicia o Nginx
EOF
</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Verifique se o arquivo foi criado corretamente: <code>cat /var/www/dockerfiles/Dockerfile.cra</code>.
            </div>

            <h4>4.3. Dockerfile para Frontends Expo Web (React Native Web)</h4>
            <div class="callout callout-info">
                <strong>Onde criar:</strong> No terminal do servidor, como usuário <code>ubuntu</code>.
                <br><strong>Caminho do arquivo:</strong> <code>/var/www/dockerfiles/Dockerfile.expo</code>
                <br><strong>Propósito:</strong> Define como construir uma aplicação Expo Web em uma imagem Docker.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">cat << 'EOF' > /var/www/dockerfiles/Dockerfile.expo
# Estágio de Build: Usa uma imagem Node.js para instalar dependências e compilar o projeto
FROM node:20-alpine AS build
WORKDIR /app
COPY package.json ./
RUN npm install # Instala as dependências
COPY . . # Copia o restante do código-fonte
ARG EXPO_PUBLIC_API_URL
ENV EXPO_PUBLIC_API_URL=${EXPO_PUBLIC_API_URL}
RUN npx expo export:web # Compila o projeto Expo para web

# Estágio Final: Usa uma imagem Nginx leve para servir os arquivos estáticos
FROM nginx:stable-alpine
COPY --from=build /app/web-build /usr/share/nginx/html # Copia os arquivos compilados para o Nginx
COPY /var/www/dockerfiles/nginx.conf /etc/nginx/conf.d/default.conf # Copia a configuração Nginx comum
EXPOSE 80 # Expõe a porta 80 do contêiner
CMD ["nginx", "-g", "daemon off;"] # Inicia o Nginx
EOF
</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Verifique se o arquivo foi criado corretamente: <code>cat /var/www/dockerfiles/Dockerfile.expo</code>.
            </div>

            <h4>4.4. Configuração Nginx Comum para Frontends</h4>
            <div class="callout callout-info">
                <strong>Onde criar:</strong> No terminal do servidor, como usuário <code>ubuntu</code>.
                <br><strong>Caminho do arquivo:</strong> <code>/var/www/dockerfiles/nginx.conf</code>
                <br><strong>Propósito:</strong> Configuração Nginx padrão para servir arquivos estáticos de frontends. Será copiada para dentro dos contêineres de frontend.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">cat << 'EOF' > /var/www/dockerfiles/nginx.conf
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;
    location / {
        try_files $uri $uri/ /index.html;
    }
}
EOF
</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Verifique se o arquivo foi criado corretamente: <code>cat /var/www/dockerfiles/nginx.conf</code>.
            </div>
        </section>

        <section id="nginx-proxy">
            <h2>5. Nginx Proxy & SSL (Let's Encrypt)</h2>
            <p>O Nginx atuará como proxy reverso, direcionando o tráfego para os contêineres corretos. O Certbot será usado para automatizar a obtenção e renovação de certificados SSL/TLS.</p>

            <h4>5.1. Criar o Docker Compose do Nginx Proxy</h4>
            <div class="callout callout-info">
                <strong>Onde executar:</strong> No terminal do servidor, como usuário <code>ubuntu</code>.
                <br><strong>Propósito:</strong> Criar o arquivo <code>docker-compose.yml</code> que orquestra o contêiner Nginx e o Certbot. Este comando já corrige as redes para usar a <code>proxy-net</code> compartilhada e esclarece como alternar entre as configurações de teste e produção.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">cat << 'EOF' > /var/www/nginx_proxy/docker-compose.yml
version: '3.3'

services:
  nginx-proxy:
    image: nginx:stable-alpine
    container_name: nginx-proxy
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      # Monta a configuração de teste por padrão.
      # Para ir para produção, comente a linha abaixo e descomente a de produção.
      - ./config_test:/etc/nginx/conf.d
      # - ./config_prod:/etc/nginx/conf.d # Descomente para produção
      - certbot-web:/var/www/certbot
      - certbot-certs:/etc/letsencrypt
    networks:
      - proxy-net # Conecta à rede compartilhada

  certbot:
    image: certbot/certbot
    container_name: certbot
    volumes:
      - certbot-web:/var/www/certbot
      - certbot-certs:/etc/letsencrypt
    # O comando abaixo é um exemplo e deve ser executado manualmente.
    # Substitua 'seu_email@example.com' e os domínios pelos seus.
    command: >
      certonly --webroot -w /var/www/certbot --force-renewal
      --email seu_email@example.com
      -d app.driverhub.com -d admin.driverhub.com
      -d batuara.org.br -d www.batuara.org.br -d admin.batuara.org.br
      --rsa-key-size 4096 --agree-tos --non-interactive
    depends_on:
      - nginx-proxy

networks:
  proxy-net:
    external: true

volumes:
  certbot-web:
  certbot-certs:
EOF
</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Após executar o comando, verifique a sintaxe do arquivo com: <code>docker-compose -f /var/www/nginx_proxy/docker-compose.yml config</code>. Se não houver erros, a sintaxe está correta.
            </div>

            <h4>5.2. Configuração Nginx para Testes (Acesso por IP)</h4>
            <div class="callout callout-info">
                <strong>Onde criar:</strong> No terminal do servidor, como usuário <code>ubuntu</code>.
                <br><strong>Caminho da pasta:</strong> <code>/var/www/nginx_proxy/config_test/</code>
                <br><strong>Propósito:</strong> Define como o Nginx irá rotear o tráfego para os frontends durante a fase de testes, usando portas específicas para cada serviço.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash"># Crie a pasta (se ainda não existir)
mkdir -p /var/www/nginx_proxy/config_test

# Arquivo para DriverHub MobileApp (Acessível em http://IP:8001)
cat << 'EOF' > /var/www/nginx_proxy/config_test/driverhub_mobile.conf
server {
    listen 8001;
    location / { proxy_pass http://driverhub-mobile-app; }
    location /api/ { proxy_pass http://driverhub-api:8080/; }
}
EOF

# Arquivo para DriverHub Dashboard (Acessível em http://IP:8002)
cat << 'EOF' > /var/www/nginx_proxy/config_test/driverhub_admin.conf
server {
    listen 8002;
    location / { proxy_pass http://driverhub-admin-dashboard; }
    location /api/ { proxy_pass http://driverhub-api:8080/; }
}
EOF

# Arquivo para Batuara Public (Acessível em http://IP:8003)
cat << 'EOF' > /var/www/nginx_proxy/config_test/batuara_public.conf
server {
    listen 8003;
    location / { proxy_pass http://batuara-public-website; }
    location /api/ { proxy_pass http://batuara-api:8080/; }
}
EOF

# Arquivo para Batuara Admin (Acessível em http://IP:8004)
cat << 'EOF' > /var/www/nginx_proxy/config_test/batuara_admin.conf
server {
    listen 8004;
    location / { proxy_pass http://batuara-admin-dashboard; }
    location /api/ { proxy_pass http://batuara-api:8080/; }
}
EOF
</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Verifique se os arquivos foram criados corretamente: <code>ls -l /var/www/nginx_proxy/config_test/</code> e <code>cat /var/www/nginx_proxy/config_test/driverhub_mobile.conf</code> (e os outros).
            </div>

            <h4>5.3. Configuração Nginx para Produção (Acesso por Domínio e HTTPS)</h4>
            <div class="callout callout-info">
                <strong>Onde criar:</strong> No terminal do servidor, como usuário <code>ubuntu</code>.
                <br><strong>Caminho da pasta:</strong> <code>/var/www/nginx_proxy/config_prod/</code>
                <br><strong>Propósito:</strong> Define como o Nginx irá rotear o tráfego para os frontends em produção, usando domínios e HTTPS.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash"># Crie a pasta
mkdir -p /var/www/nginx_proxy/config_prod

# Arquivo para DriverHub
cat << 'EOF' > /var/www/nginx_proxy/config_prod/driverhub.conf
server {
    listen 80;
    server_name app.driverhub.com admin.driverhub.com;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    server_name app.driverhub.com;

    ssl_certificate /etc/letsencrypt/live/app.driverhub.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/app.driverhub.com/privkey.pem;

    location / {
        proxy_pass http://driverhub-mobile-app;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /api/ {
        proxy_pass http://driverhub-api:8080/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}

server {
    listen 443 ssl;
    server_name admin.driverhub.com;

    ssl_certificate /etc/letsencrypt/live/admin.driverhub.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/admin.driverhub.com/privkey.pem;

    location / {
        proxy_pass http://driverhub-admin-dashboard;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /api/ {
        proxy_pass http://driverhub-api:8080/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
EOF

# Arquivo para Batuara.net
cat << 'EOF' > /var/www/nginx_proxy/config_prod/batuara.conf
server {
    listen 80;
    server_name batuara.org.br www.batuara.org.br admin.batuara.org.br;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    server_name batuara.org.br www.batuara.org.br;

    ssl_certificate /etc/letsencrypt/live/batuara.org.br/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/batuara.org.br/privkey.pem;

    location / {
        proxy_pass http://batuara-public-website;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /api/ {
        proxy_pass http://batuara-api:8080/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}

server {
    listen 443 ssl;
    server_name admin.batuara.org.br;

    ssl_certificate /etc/letsencrypt/live/admin.batuara.org.br/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/admin.batuara.org.br/privkey.pem;

    location / {
        proxy_pass http://batuara-admin-dashboard;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /api/ {
        proxy_pass http://batuara-api:8080/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
EOF
</code></pre>
            </div>
        </section>

        <div class="callout callout-success">
            <strong>Verificação:</strong> Verifique se os arquivos foram criados corretamente: <code>ls -l /var/www/nginx_proxy/config_prod/</code>.
        </div>

        <section id="backups">
            <h2>6. Backups Automatizados do Banco de Dados</h2>
            <p>É crucial ter backups regulares e automatizados dos seus bancos de dados. Vamos criar um script simples e agendá-lo com <code>cron</code>.</p>

            <h4>6.1. Criar Diretório para Backups</h4>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">sudo mkdir -p /var/backups/postgres
sudo chown -R ubuntu:ubuntu /var/backups/postgres
</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Para confirmar que o diretório foi criado e as permissões estão corretas, execute: <code>ls -ld /var/backups/postgres</code>. Você deverá ver o diretório listado com <code>ubuntu</code> como proprietário.
            </div>

            <h4>6.2. Criar e Tornar o Script de Backup Executável</h4>
            <div class="callout callout-info">
                <strong>Onde executar:</strong> No terminal do servidor.
                <br><strong>Propósito:</strong> Criar o script de backup e dar a ele permissão de execução em um único passo. O script também foi melhorado para evitar erros caso os contêineres não estejam rodando.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash"># Cria o arquivo de script
cat << 'EOF' > /var/www/backup_db.sh
#!/bin/bash

# Carrega variáveis de ambiente dos arquivos .env, se existirem
[ -f /var/www/driverhub/.env ] && source /var/www/driverhub/.env
[ -f /var/www/batuara_net/.env ] && source /var/www/batuara_net/.env

TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
BACKUP_DIR="/var/backups/postgres"

# Backup DriverHub (apenas se o contêiner estiver rodando)
if [ $(docker ps -q -f name=driverhub-db) ]; then
    echo "Fazendo backup do banco de dados DriverHub..."
    docker exec driverhub-db pg_dump -U driverhub_user -d driverhub_db > "${BACKUP_DIR}/driverhub_db_${TIMESTAMP}.sql"
fi

# Backup Batuara.net (apenas se o contêiner estiver rodando)
if [ $(docker ps -q -f name=batuara-db) ]; then
    echo "Fazendo backup do banco de dados Batuara.net..."
    docker exec batuara-db pg_dump -U batuara_user -d batuara_db > "${BACKUP_DIR}/batuara_db_${TIMESTAMP}.sql"
fi

# Limpar backups antigos (manter os últimos 7 dias)
find "${BACKUP_DIR}" -type f -name "*.sql" -mtime +7 -delete
echo "Limpeza de backups antigos concluída."

EOF

# Torna o script executável
chmod +x /var/www/backup_db.sh
</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Verifique se o script foi criado e é executável com: <code>ls -l /var/www/backup_db.sh</code>. A saída deve mostrar as permissões de execução (ex: <code>-rwxr-xr-x</code>).
            </div>

            <h4>6.3. Agendar Backup com Cron</h4>
            <p>Edite o crontab para agendar o script. Por exemplo, para rodar todo dia à 1h da manhã.</p>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">crontab -e</code></pre>
            </div>
            <p>Adicione a seguinte linha no final do arquivo que abrir:</p>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash">0 1 * * * /var/www/backup_db.sh >> /var/log/backup_db.log 2>&1</code></pre>
            </div>
            <div class="callout callout-info">
                <strong>Explicação:</strong>
                <ul>
                    <li><code>0 1 * * *</code>: Roda à 1h da manhã, todos os dias.</li>
                    <li><code>/var/www/backup_db.sh</code>: Caminho para o seu script.</li>
                    <li><code>>> /var/log/backup_db.log 2>&1</code>: Redireciona a saída (stdout e stderr) para um arquivo de log.</li>
                </ul>
            </div>
            <div class="callout callout-success">
                <strong>Verificação:</strong> Para confirmar que o agendamento foi salvo corretamente, liste o conteúdo do seu crontab com: <code>crontab -l</code>. A saída deve mostrar a linha que você adicionou.
            </div>
        </section>

        <section id="configuracao-dns-registrobr">
            <h2>7. Configuração DNS (Registro.br)</h2>
            <p>Esta seção detalha como configurar os registros DNS no painel do Registro.br para que seus domínios apontem para o IP público do seu servidor Oracle Cloud. Lembre-se que a configuração é feita <strong>individualmente para cada domínio</strong> que você possui.</p>

            <h4>7.1. Acessando o Painel do Registro.br</h4>
            <p>1. Acesse <a href="https://registro.br/" target="_blank">registro.br</a> e faça login na sua conta.</p>
            <p>2. Na lista de seus domínios, clique no domínio que deseja configurar (ex: <code>batuara.org.br</code> ou <code>driverhub.com</code>).</p>
            <p>3. Procure por uma opção como <strong>"Configurar DNS"</strong>, <strong>"Editar Zona DNS"</strong> ou <strong>"Gerenciar DNS"</strong>. Geralmente, está em um menu lateral ou em uma aba.</p>
            <p>4. Se houver, selecione o modo de edição avançado ou de zona.</p>

            <h4>7.2. Configuração para o Domínio <code>driverhub.com</code></h4>
            <p>No painel de configuração de DNS para o domínio <code>driverhub.com</code>, adicione os seguintes registros:</p>
            <div class="callout callout-info">
                <strong>IP de Destino para todos os registros:</strong> <code>129.153.86.168</code>
            </div>
            <table class="table">
                <thead>
                    <tr><th>Domínio</th><th>Tipo</th><th>Nome/Host</th><th>Valor/Destino</th></tr>
                </thead>
                <tbody>
                    <tr><td>driverhub.com</td><td>A</td><td>app</td><td>129.153.86.168</td></tr>
                    <tr><td>driverhub.com</td><td>A</td><td>admin</td><td>129.153.86.168</td></tr>
                </tbody>
            </table>

            <h4>7.3. Configuração para o Domínio <code>batuara.org.br</code></h4>
            <p>No painel de configuração de DNS para o domínio <code>batuara.org.br</code>, adicione os seguintes registros:</p>
            <div class="callout callout-info">
                <strong>IP de Destino para todos os registros:</strong> <code>129.153.86.168</code>
            </div>
            <table class="table">
                <thead>
                    <tr><th>Domínio</th><th>Tipo</th><th>Nome/Host</th><th>Valor/Destino</th></tr>
                </thead>
                <tbody>
                    <tr><td>batuara.org.br</td><td>A</td><td>@ ou (vazio)</td><td>129.153.86.168</td></tr>
                    <tr><td>batuara.org.br</td><td>CNAME</td><td>www</td><td>batuara.org.br</td></tr>
                    <tr><td>batuara.org.br</td><td>A</td><td>admin</td><td>129.153.86.168</td></tr>
                </tbody>
            </table>
            <div class="callout callout-warning">
                <strong>Atenção:</strong> A propagação de DNS pode levar de alguns minutos a algumas horas. Teste a conectividade com <code>ping seu_dominio.com</code> ou <code>dig seu_dominio.com</code>.
            </div>
        </section>

        <section id="manutencao">
            <h2>8. Manutenção</h2>
            <p>Comandos úteis para gerenciar seu ambiente no dia a dia.</p>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash"># Ver todos os contêineres em execução
docker ps

# Ver logs de um serviço específico (ex: driverhub-api)
docker-compose -f /var/www/driverhub/docker-compose.yml logs -f api

# Parar todas as aplicações
cd /var/www/driverhub && docker-compose down
cd /var/www/batuara_net && docker-compose down
cd /var/www/nginx_proxy && docker-compose down

# Atualizar uma aplicação após mudanças no Git (ex: DriverHub)
cd /var/www/driverhub
git pull # Puxar as atualizações
docker-compose up -d --build # Reconstruir e reiniciar
</code></pre>
            </div>
        </section>

        <section id="validacao-final">
            <h2>9. Validação Final da Infraestrutura</h2>
            <p>Após concluir todas as etapas anteriores, você pode executar um script de validação automatizado para garantir que toda a infraestrutura base foi configurada corretamente. Este script verificará permissões, arquivos, serviços e configurações de rede.</p>

            <h4>9.1. Criar e Executar o Script de Validação</h4>
            <div class="callout callout-info">
                <strong>Onde executar:</strong> No terminal do servidor, na sua pasta home (<code>~</code>).
                <br><strong>Propósito:</strong> Criar e executar um script que testa todos os pontos críticos da configuração da infraestrutura.
            </div>
            <div class="code-block">
                <button class="copy-btn">Copiar</button>
                <pre><code class="language-bash"># Cria o script de validação na sua pasta home
cat << 'EOF' > ~/validate_infra.sh
#!/bin/bash

# Cores para a saída
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # Sem Cor

# Função para printar sucesso ou falha
check() {
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}OK${NC}"
    else
        echo -e "${RED}FALHOU${NC}"
    fi
}

echo "Iniciando validação da infraestrutura..."

# 1. Pacotes
echo -n "Verificando pacote 'docker.io'... "
dpkg -s docker.io &> /dev/null; check
echo -n "Verificando pacote 'docker-compose'... "
dpkg -s docker-compose &> /dev/null; check
echo -n "Verificando pacote 'nginx'... "
dpkg -s nginx &> /dev/null; check

# 2. Serviço Docker
echo -n "Verificando se o serviço Docker está ativo... "
sudo systemctl is-active --quiet docker; check
echo -n "Verificando permissão do usuário 'ubuntu' no grupo docker... "
docker ps &> /dev/null; check

# 3. Firewall (UFW)
# 3. Firewall (UFW)
echo -n "Verificando se o UFW está ativo... "
sudo ufw status | grep -q 'Status: active'; check
echo -n "Verificando regra do UFW para 'OpenSSH'... "
sudo ufw status | grep 'OpenSSH' | grep -q 'ALLOW'; check
echo -n "Verificando regra do UFW para 'Nginx Full'... "
sudo ufw status | grep 'Nginx Full' | grep -q 'ALLOW'; check
echo -n "Verificando regra do UFW para porta 8001... "
sudo ufw status | grep '8001/tcp' | grep -q 'ALLOW'; check
echo -n "Verificando regra do UFW para porta 8002... "
sudo ufw status | grep '8002/tcp' | grep -q 'ALLOW'; check
echo -n "Verificando regra do UFW para porta 8003... "
sudo ufw status | grep '8003/tcp' | grep -q 'ALLOW'; check
echo -n "Verificando regra do UFW para porta 8004... "
sudo ufw status | grep '8004/tcp' | grep -q 'ALLOW'; check

# 4. Estrutura de Arquivos e Permissões
echo -n "Verificando permissão de /var/www para o usuário 'ubuntu'... "
[ "$(stat -c '%U' /var/www)" == "ubuntu" ]; check
echo -n "Verificando existência do diretório /var/www/nginx_proxy/config_test... "
[ -d /var/www/nginx_proxy/config_test ]; check
echo -n "Verificando existência do diretório /var/www/nginx_proxy/config_prod... "
[ -d /var/www/nginx_proxy/config_prod ]; check
echo -n "Verificando existência do diretório /var/backups/postgres... "
[ -d /var/backups/postgres ]; check

# 5. Arquivos de Configuração
FILES_TO_CHECK=(
    "/var/www/dockerfiles/Dockerfile.vite"
    "/var/www/dockerfiles/Dockerfile.cra"
    "/var/www/dockerfiles/Dockerfile.expo"
    "/var/www/dockerfiles/nginx.conf"
    "/var/www/nginx_proxy/docker-compose.yml"
    "/var/www/nginx_proxy/config_test/driverhub_mobile.conf"
    "/var/www/nginx_proxy/config_prod/driverhub.conf"
    "/var/www/backup_db.sh"
)
for file in "${FILES_TO_CHECK[@]}"; do
    echo -n "Verificando existência do arquivo ${file}... "
    [ -f "$file" ]; check
done

# 6. Rede Docker
echo -n "Verificando existência da rede Docker 'proxy-net'... "
docker network inspect proxy-net &> /dev/null; check

# 7. Script de Backup
echo -n "Verificando se o script de backup é executável... "
[ -x /var/www/backup_db.sh ]; check

# 8. Agendamento Cron
echo -n "Verificando agendamento do backup no crontab... "
crontab -l | grep -q '/var/www/backup_db.sh'; check

echo "Validação concluída."

EOF

# Torna o script de validação executável
chmod +x ~/validate_infra.sh

# Executa o script
~/validate_infra.sh
</code></pre>
            </div>
            <div class="callout callout-success">
                <strong>Resultado Esperado:</strong> Após executar o comando, você verá uma lista de verificações, cada uma seguida por um "OK" em verde. Se alguma verificação falhar, ela será marcada com "FALHOU" em vermelho, indicando exatamente qual parte da configuração precisa ser revisada.
            </div>
        </section>

    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        document.querySelectorAll('.copy-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const code = btn.nextElementSibling.querySelector('code').innerText;
                navigator.clipboard.writeText(code).then(() => {
                    btn.innerText = 'Copiado!';
                    setTimeout(() => {
                        btn.innerText = 'Copiar';
                    }, 2000);
                });
            });
        });
    </script>
</body>
</html>